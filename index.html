<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Mini Trello — Kanban + Matriz + Agenda (Otimizado v7.3)</title>
  <style>
    :root{--bg:#0f1a2a;--panel:#0f223d;--ink:#e9f1ff;--brand:#1976d2;--muted:#9fb3d2;--card:#112b4a}
    *{box-sizing:border-box}
    html,body{height:100%;-webkit-tap-highlight-color:transparent; overflow: hidden;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--ink);background:var(--bg); display: flex; flex-direction: column;}
    header.app{position:sticky;top:0;z-index:10;display:flex;gap:10px;align-items:center;padding:10px 12px;background:var(--brand);color:#fff;flex-wrap:wrap;transition:background-color .3s; flex-shrink: 0;}
    header.app.filters-active{background:#b85d00}
    header.app h1{margin:0;font-size:18px;font-weight:700; margin-right: auto;} /* Push buttons to the right */
    header.app input, header.app button{border:none;border-radius:8px;padding:6px 10px;background:#0e58a5;color:#fff}
    header.app button{cursor:pointer}
    header.app button.active{background:#ffd54f;color:#10243a} /* Style for active toggle buttons */
    #sumTimersDisplay { font-weight: bold; background: rgba(0,0,0,0.2); padding: 4px 8px; border-radius: 6px; margin-left: 5px; margin-right: 5px; cursor: help;} /* Added cursor */
    .badge{display:inline-block;background:#ffd54f;color:#10243a;font-weight:700;border-radius:999px;padding:2px 8px;font-size:12px;border:1px solid rgba(0,0,0,.15)}
    .badge[hidden]{display:none!important}

    .workspace {
        display: flex;
        flex-direction: row;
        height: calc(100vh - 58px); /* Full height minus header */
        padding: 12px;
        gap: 12px;
        transition: gap .3s ease-in-out;
        position: relative; /* Needed for absolute positioning of toggles */
        overflow: hidden; /* Prevent body scroll */
    }

    #main-content {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Allow this main area to scroll */
        min-width: 0;
        position: relative; /* For toggle buttons */
        transition: flex .3s ease-in-out, width .3s ease-in-out, min-width .3s ease-in-out, opacity .3s ease-in-out;
        width: 100%;
    }

    #main-content.collapsed {
        flex: 0 0 0px; /* Collapse completely */
        min-width: 0;
        opacity: 0;
        padding: 0;
        overflow: hidden;
    }

    .board-container, .matrix-container {
        position: relative;
        transition: height .3s ease-in-out, min-height .3s ease-in-out, opacity .3s ease-in-out, padding .3s ease-in-out, flex-grow .3s ease-in-out, flex-shrink .3s ease-in-out;
        overflow: hidden; /* Hide content during collapse */
        flex-shrink: 0; /* Prevent shrinking initially */
    }
     .board-container.collapsed, .matrix-container.collapsed {
        height: 0 !important;
        min-height: 0 !important;
        padding-top: 0;
        padding-bottom: 0;
        opacity: 0;
        border: none; /* Avoid border showing when collapsed */
        margin: 0;
        flex-grow: 0; /* Don't grow when collapsed */
        flex-shrink: 1; /* Allow shrinking when collapsed */
    }

    /* Adjust flex properties, Kanban less likely to grow than Matrix if space is tight */
    .board-container { flex-grow: 0; display: flex; flex-direction: column;}
    .matrix-container { flex-grow: 1; display: flex; flex-direction: column; min-height: 300px; /* Ensure matrix has minimum space */}


    .board {
        display: flex;
        gap: 12px;
        align-items: flex-start;
        padding-bottom: 10px;
        overflow-x: auto;
        min-height: 150px; /* Give it some initial height */
    }

    .matrix {
        display: grid;
        grid-template-columns: 40px 1fr 1fr;
        grid-template-rows: 40px minmax(100px, auto) minmax(100px, auto); /* Ensure rows have min height */
        gap: 12px;
        align-items: stretch; /* Stretch items vertically */
        padding-top: 16px;
        min-height: 300px; /* Minimum height for the grid */
        flex-grow: 1; /* Allow matrix grid to take available space */
    }
     .matrix .list { /* Make lists inside matrix stretch */
        align-self: stretch;
        min-height: 100px; /* Ensure list has some height */
    }

    #agenda-sidebar {
        flex-basis: 260px;
        flex-shrink: 0;
        display: flex;
        flex-direction: column;
        overflow: hidden; /* Control overflow for transition */
        transition: flex-basis .3s ease-in-out, min-width .3s ease-in-out, padding .3s ease-in-out, opacity .3s ease-in-out;
        min-width: 260px;
        position: relative; /* For toggle button */
    }

    .workspace.agenda-collapsed #agenda-sidebar {
        flex-basis: 0;
        min-width: 0;
        opacity: 0;
        padding: 0;
    }

    /* Remove toggle tabs */
    .toggle-tab { display: none; }

    .list{background:var(--panel);border:1px solid #183453;border-radius:10px;display:flex;flex-direction:column;min-width:240px;flex-shrink:0}
    .list header{display:flex;gap:8px;align-items:center;padding:8px 10px;border-bottom:1px solid #19375b;background:#122b4a; flex-shrink: 0;} /* Prevent header shrink */
    .list header input.title{flex:1;border:none;border-radius:8px;padding:6px 8px;background:#0e2542;color:var(--ink)}
    .cards{display:flex;flex-direction:column;gap:6px;padding:8px;min-height:34px; overflow-y: auto; flex-grow: 1;} /* Allow cards area to scroll if needed */
    .card{background:var(--card);border:1px solid #20486f;border-left:8px solid transparent;border-radius:8px;padding:8px;cursor:grab;user-select:none;position:relative;transition:opacity .2s, transform .2s}
    .card.dragging{opacity:0.5;transform:rotate(3deg)}
    .card.selected{outline:2px solid #2a71ff;background:#0f2f57}
    .card.editing { background: #1a4b7f; } /* Highlight while editing */
    .card .text{white-space:pre-wrap; min-height: 1em;} /* Ensure editable area has height */
    .meta{margin-top:6px;font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .dot{width:10px;height:10px;border-radius:50%;display:inline-block;border:1px solid #375b86}
    .timer-display{font-size:11px;font-weight:bold;padding:1px 5px;border-radius:4px; background: rgba(0,0,0,.2);}
    .kebab{position:absolute;top:2px;right:2px;background:transparent;border:1px solid transparent;color:#9fc1ff;border-radius:6px;padding:0 6px;line-height:20px;cursor:pointer}
    .add{padding:8px;border-top:1px solid #19375b; flex-shrink: 0;}.add .row{display:flex;gap:6px} /* Prevent add section shrink */
    .add input[type=text]{flex:1;border:1px solid #2a4e78;border-radius:8px;padding:8px;background:#0b2240;color:var(--ink)}

    .axis{display:flex;align-items:center;justify-content:center;font-weight:700;color:#cfe0ff;background:#102b4f;border:1px solid #1a4e78;border-radius:10px}
    .axis.corner{background:transparent;border:none}
    .axis.axis-y{writing-mode:vertical-rl;transform:rotate(180deg);padding:4px 0}
    .quad-label{font-weight:700;color:#cfe0ff}
    .list[data-type="quad"]{min-width:unset}
    .list[data-type="quad"][data-quad="Q1"]{background:#0f2f2a;border-color:#1e5b4e}.list[data-type="quad"][data-quad="Q1"] header{background:#104239}
    .list[data-type="quad"][data-quad="Q2"]{background:#0f243a;border-color:#1b4e84}.list[data-type="quad"][data-quad="Q2"] header{background:#0e3155}
    .list[data-type="quad"][data-quad="Q3"]{background:#3a290f;border-color:#7c5a19}.list[data-type="quad"][data-quad="Q3"] header{background:#5a4014}
    .list[data-type="quad"][data-quad="Q4"]{background:#3a0f12;border-color:#7c1920}.list[data-type="quad"][data-quad="Q4"] header{background:#5a1419}

    .schedule{background:var(--panel);border:1px solid #183453;border-radius:12px;width:100%; height:100%; display: flex; flex-direction: column; overflow: hidden;}
    .schedule header{position:sticky;top:0;z-index:1;display:flex;justify-content:space-between;align-items:center;padding:8px 10px;background:#0b437e;color:#fff;border-top-left-radius:12px;border-top-right-radius:12px}
    #slots { overflow-y: auto; flex-grow: 1; }
    .schedule header input[type=date]{background:#0b2240;color:#fff;border:1px solid #2a4e78;border-radius:8px;padding:6px 8px}
    .slot{border-bottom:1px dashed #244b78}.slot>div.head{display:flex;align-items:center;gap:6px;padding:0 4px}
    .slot .time{font-weight:700;font-size:11px;color:#9fc1ff}
    .slot .cards{display:none;padding:4px;min-height:28px}.slot.has-items .cards{display:block}
    .slot.hover{background:#0e2446;box-shadow:inset 0 0 0 2px #1976d2}
    .goal-slot { background: #1c3a61; border-bottom: 1px solid #3a6a9e; } /* Highlight for goal slot */
    .goal-slot > .head .goal-label { font-weight: bold; color: #ffd54f; }

    .placeholder{height:38px;border:2px dashed #1976d2;border-radius:8px;background:#0e2446;margin:4px 0}
    .ctx{position:fixed;background:#0b1220;color:#fff;border:1px solid #24314a;border-radius:8px;min-width:240px;box-shadow:0 10px 30px rgba(0,0,0,.3);display:none;z-index:1000} /* Increased min-width slightly */
    .ctx button{display:flex; align-items: center; gap: 8px; width:100%;text-align:left;background:transparent;border:none;color:#dbe7ff;padding:10px 12px;border-radius:0;cursor:pointer}.ctx button:hover{background:#1a2842}
    .ctx .shortcut { margin-left: auto; font-size: 0.8em; color: var(--muted); padding-left: 10px; } /* Style for shortcuts */
    .ctx .sep{height:1px;background:#23314a;margin:6px 0}
    .ctx-sub{position:absolute;left:100%;top:0;background:#0b1220;color:#fff;border:1px solid #24314a;border-radius:8px;min-width:240px;max-height:300px;overflow:auto;box-shadow:0 6px 20px rgba(0,0,0,.3);display:none}
    .list header .more{margin-left:auto;background:transparent;border:1px solid transparent;color:#9fc1ff;border-radius:6px;padding:0 6px;line-height:20px;cursor:pointer}
    .modal-wrap{position:fixed;inset:0;background:rgba(0,0,0,.45);display:flex;align-items:center;justify-content:center;z-index:9999}
    .modal{background:#0b1220;color:#fff;border:1px solid #24314a;border-radius:12px;min-width:280px;max-width:94vw;padding:14px 14px 10px;box-shadow:0 20px 60px rgba(0,0,0,.5)}
    .modal h3{margin:0 0 10px;font-size:16px}
    .modal .row{margin-top:12px;display:flex;gap:8px;justify-content:flex-end}
    .modal .row button{background:#1976d2;border:none;border-radius:8px;color:#fff;padding:8px 10px;cursor:pointer}
    .modal .row button.cancel{background:#6b7a93}
    /* Style for import options modal */
    .import-options button { margin: 5px; flex-grow: 1;}


    @keyframes spinner_zKoa{100%{transform:rotate(360deg)}}@keyframes spinner_YpZS{0%{stroke-dasharray:0 150;stroke-dashoffset:0}47.5%{stroke-dasharray:42 150;stroke-dashoffset:-16}95%,100%{stroke-dasharray:42 150;stroke-dashoffset:-59}}
    .spinner_V8m1{transform-origin:center;animation:spinner_zKoa 2s linear infinite}.spinner_V8m1 circle{stroke-linecap:round;animation:spinner_YpZS 1.5s ease-in-out infinite}
    @keyframes flash { 0%, 100% { background-color: var(--card); } 50% { background-color: #ffcc00; color: #000; } }

    @media (max-width: 700px){
        .workspace{
            flex-direction: column;
            overflow-y: auto;
            padding: 8px; /* Reduce padding on small screens */
            gap: 8px;
        }
        #main-content {
             overflow: visible; /* Allow content to determine height */
             height: auto;
        }
        #agenda-sidebar{display:none}
        .board { order: 1; overflow: visible; min-height: unset;} /* Kanban first */
        .matrix { order: 2; margin-top: 16px; min-height: unset;} /* Matrix second */
        .list { min-width: unset; width: 100%; margin-bottom: 12px; }
        header.app { /* Allow header buttons to wrap */
             height: auto;
             padding-bottom: 10px; /* Add padding if buttons wrap */
        }
        header.app h1 { margin-right: 10px; } /* Reduce margin for title */
        /* Hide toggle buttons on small screens as panels are handled differently */
        #toggleBoardBtn, #toggleMatrixBtn, #toggleAgendaBtn { display: none; }
    }
  </style>
</head>
<body>
<header class="app" id="appHeader">
  <h1>Mini Trello</h1>
  <button id="undo" title="Desfazer (Ctrl+Z)">⟲</button>
  <button id="redo" title="Refazer (Ctrl+Shift+Z)">⟳</button>
  <button id="filterColorsBtn" title="Filtrar por cor">Filtro de cor</button>
  <span id="filtersOn" class="badge" hidden>Filtros ativos</span>
  <input id="fTime" type="text" placeholder="Tempo (ex: 45m)" style="width:120px" title="Filtra cartões com tempo definido menor ou igual ao valor. Use 'm' para minutos, 'h' para horas. Ex: 90m ou 1h 30m">
  <strong id="sumTimersDisplay" title="Selecionado: 0:00 / Filtrado: 0:00 / Total: 0:00">0:00 min</strong> <!-- Display updated -->
  <label>De <input id="fFrom" type="date"></label>
  <label>Até <input id="fTo" type="date"></label>
  <button id="clearFilters">Limpar filtros</button>
   <!-- Panel Toggle Buttons -->
  <button id="toggleBoardBtn" title="Mostrar/Ocultar Kanban">☰</button>
  <button id="toggleMatrixBtn" title="Mostrar/Ocultar Matriz">⊞</button>
  <button id="toggleAgendaBtn" title="Mostrar/Ocultar Agenda">🗓️</button>
  <!-- End Panel Toggle Buttons -->
  <button id="quickSaveBtn" title="Salvar Backup Rápido">💾</button> <!-- Quick Save Button -->
  <button id="addList">+ Lista</button>
  <button id="exportJson" title="Baixar backup JSON">Exportar JSON</button>
  <button id="importJsonBtn" title="Restaurar de JSON">Importar JSON</button>
  <input id="importFile" type="file" style="display:none" /> <!-- Accept attribute removed -->
  <button id="reset">Resetar</button>
</header>
<section class="workspace">
    <div id="main-content">
        <div class="board-container">
            <main class="board" id="board"></main>
        </div>
        <div class="matrix-container">
            <section class="matrix" id="matrix"></section>
        </div>
    </div>
    <aside id="agenda-sidebar">
        <div class="schedule" id="schedule">
            <header>
                <strong>AGENDA</strong>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <input id="agendaDate" type="date" />
                    <button id="copyDay" title="Copiar agenda de outra data">Copiar</button>
                </div>
            </header>
            <div id="slots"></div>
        </div>
    </aside>
</section>

<!-- Updated Context Menu Structure -->
<div id="ctx" class="ctx">
  <button data-action="timer">⏱️ Timer <span class="shortcut">Alt+T</span></button>
  <button data-action="color">🎨 Editar cor <span class="shortcut">Alt+C</span></button>
  <button data-action="date">📅 Editar Data <span class="shortcut">Alt+D</span></button>
  <div class="sep"></div>
  <button data-action="gemini-subtasks">✨ Gerar subtarefas</button>
  <button data-action="gemini-organize">✨ Organizar na Matriz</button>
   <div class="sep"></div>
  <button data-action="dup">➕ Duplicar <span class="shortcut">Ctrl+D</span></button>
  <button data-action="del">🗑️ Excluir <span class="shortcut">Del</span></button>
  <div id="ctx-move" style="position:relative">
    <button data-action="move">➡️ Mover para ▶</button>
    <div class="ctx-sub" id="ctx-move-sub"></div>
  </div>
  <div id="ctx-move-all" style="position:relative">
    <button data-action="move-all">➡️ Mover TODOS desta Lista ▶</button>
    <div class="ctx-sub" id="ctx-moveall-sub"></div>
  </div>
  <button data-action="del-all">🗑️ Excluir TODOS desta Lista</button>
</div>

<div id="ctx-list" class="ctx">
  <button data-action="list-del">🗑️ Excluir lista</button>
  <button data-action="list-move-all">➡️ Mover todos para ▶</button>
  <div class="ctx-sub" id="ctx-list-move-sub"></div>
</div>

<script>
(function(){
  // ===== Helpers =====
  function el(t,c){var n=document.createElement(t); if(c) n.className=c; return n;}
  function $$(s,r){if(!r) r=document; return Array.prototype.slice.call(r.querySelectorAll(s));}
  function to2(n){return (n<10?'0'+n:''+n);}
  function formatSecondsToTime(totalSeconds) { // Helper to format time
      if (totalSeconds <= 0) return '0:00 min'; // Add min here too for consistency if desired
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      return `${hours > 0 ? hours + ':' : ''}${to2(minutes)} min`; // Append ' min'
  }

  var LS_KEY='mini-trello-restore';
  var __persistTick=null, __muteHistory=0;
  function withMute(fn){ __muteHistory++; try{ return fn(); } finally { __muteHistory--; } }

  var boardEl=document.getElementById('board'); // Renamed from board to avoid conflict
  var schedule=document.getElementById('schedule');
  var slotsRoot=document.getElementById('slots');
  var matrixEl=document.getElementById('matrix'); // Renamed from matrix
  var sumTimersDisplay = document.getElementById('sumTimersDisplay'); // Get the display element
  var allCards = []; // Cache de todos os elementos de cartão para performance
  var globalTimerInterval = null;
  var selected = new Set(); // Moved selection set here to be accessible by timer sum
  var lastMouseX = 0, lastMouseY = 0; // Track mouse position

  // Track mouse position
  document.addEventListener('mousemove', (e) => {
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  });

  // ===== Sum Timers Logic =====
  function updateTotalTimerDisplay() {
      let selectedSeconds = 0;
      let visibleSeconds = 0;
      let totalSecondsAll = 0;

      // Calculate sum for selected cards
      if (selected.size > 0) {
          selected.forEach(card => {
              selectedSeconds += parseInt(card.dataset.timerTotal || '0', 10);
          });
      }

      // Calculate sum for all *visible* cards and *total* cards
      allCards.forEach(card => {
          const cardTime = parseInt(card.dataset.timerTotal || '0', 10);
          totalSecondsAll += cardTime;
          // Check if card is currently displayed (not display: none)
          // Use computed style for a more robust visibility check
          const style = window.getComputedStyle(card);
          if (style.display !== 'none' && style.visibility !== 'hidden' && card.offsetParent !== null) {
               visibleSeconds += cardTime;
          }
      });

      // Determine text content based on selection
      const displayText = selected.size > 0 ? formatSecondsToTime(selectedSeconds) : formatSecondsToTime(visibleSeconds);
      sumTimersDisplay.textContent = displayText;

      // Update tooltip with all three values
      sumTimersDisplay.title = `Selecionado: ${formatSecondsToTime(selectedSeconds)} / Filtrado: ${formatSecondsToTime(visibleSeconds)} / Total: ${formatSecondsToTime(totalSecondsAll)}`;
  }


  // ===== Persistência + Histórico =====
  function cardToData(c){
    var t=c.querySelector('.text');
    return{ text:(t?t.textContent:'').trim(), color:c.dataset.color||'', due:c.dataset.due||'', when:c.dataset.when||'', timerTotal:c.dataset.timerTotal||'', timerLeft:c.dataset.timerLeft||'', timerState:c.dataset.timerState||'' };
  }
  function serialize(){
         var data=[];

         // 1. Serialize Kanban lists IN DOM ORDER
         $$('.list[data-type="kanban"]', boardEl).forEach(function(l) {
             const title = l.querySelector('.title').value;
             // Get cards from this list that are in the main cache
             const cardsInList = $$('.card', l).map(c => allCards.find(cacheCard => cacheCard === c)).filter(Boolean).map(cardToData);
             data.push({ type: 'kanban', title: title, cards: cardsInList });
         });

         // 2. Serialize Matrix lists IN DOM ORDER
         if (matrixEl) {
             $$('.list[data-type="quad"]', matrixEl).forEach(function(l) {
                 const quad = l.dataset.quad;
                 // Get cards from this list that are in the main cache
                 const cardsInList = $$('.card', l).map(c => allCards.find(cacheCard => cacheCard === c)).filter(Boolean).map(cardToData);
                 data.push({ type: 'quad', quad: quad, cards: cardsInList });
             });
         }

         // 3. Serialize Agenda cards FROM CACHE (as they might not be in DOM)
         const agendaGoalCards = allCards.filter(c => c.dataset.when && c.dataset.when.endsWith('TGOAL')).map(cardToData);
         if (agendaGoalCards.length > 0) {
             data.push({ type: 'goal', goal: true, cards: agendaGoalCards });
         }

         const agendaTimeCards = {};
         allCards.filter(c => c.dataset.when && /T\d{2}:\d{2}$/.test(c.dataset.when)).forEach(c => {
             const time = c.dataset.when.substring(11);
             if (!agendaTimeCards[time]) agendaTimeCards[time] = [];
             agendaTimeCards[time].push(cardToData(c));
         });
         for (const time in agendaTimeCards) {
              data.push({ type: 'time', time: time, cards: agendaTimeCards[time] });
         }

        return data;
  }


  var HIST_LIMIT=120; var hist=[], cursor=-1;
  function pushHistory(snap){ hist=hist.slice(0,cursor+1); hist.push(snap); if(hist.length>HIST_LIMIT) { hist.shift(); } cursor=hist.length-1; updateUndoUi(); }
  function capture(){ if(__muteHistory>0) return; try{ pushHistory(serialize()); }catch(e){} }
  function canUndo(){ return cursor>0; }
  function canRedo(){ return cursor>=0 && cursor<hist.length-1; }
  function updateUndoUi(){ document.getElementById('undo').disabled=!canUndo(); document.getElementById('redo').disabled=!canRedo(); }
  function doUndo(){ if(!canUndo()) return; withMute(function(){ cursor--; restore(hist[cursor]); }); updateUndoUi(); }
  function doRedo(){ if(!canRedo()) return; withMute(function(){ cursor++; restore(hist[cursor]); }); updateUndoUi(); }

  function persist(){ if(__muteHistory>0) return; clearTimeout(__persistTick); __persistTick=setTimeout(function(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(serialize())); }catch(e){} capture(); }, 250); }

  function duplicateCards(cards) {
    if (!cards || !cards.length) return;
    let newCards = []; // Keep track of newly created cards
    cards.forEach(function(c) {
      var newData = cardToData(c);
      // Remove 'when' data if duplicating outside agenda context
      if (!c.closest('#agenda-sidebar')) {
          newData.when = '';
      }
      var newCard = createCard(newData);
      newCards.push(newCard); // Add to list
      c.parentElement.insertBefore(newCard, c.nextSibling);
      if (newData.when) { // If it had a 'when', ensure it stays in allCards cache
        // It's added to allCards automatically by createCard
      }
    });
    persist();
    updateSlotsHasItems(); // Update agenda view if needed
    updateTotalTimerDisplay(); // Update total time
  }


  function initDemo() {
    withMute(function() {
      var toDo = createList('Para Fazer');
      toDo.querySelector('.cards').appendChild(createCard({text: 'Tarefa importante e urgente', color: '#104239', timerTotal: '1800'})); // Cor Q1, 30 min
      toDo.querySelector('.cards').appendChild(createCard({text: 'Agendar reunião com a equipe', color: '#0e3155', timerTotal: '3600'})); // Cor Q2, 60 min
      toDo.querySelector('.cards').appendChild(createCard({text: 'Revisar o relatório de vendas'}));

      createList('Em Andamento');
      createList('Feito');

      if (matrixEl) {
        var q1 = matrixEl.querySelector('.list[data-quad="Q1"] .cards');
        q1.appendChild(createCard({text: 'Crise: Resolver problema no servidor de produção!', color: '#104239', timerTotal: '7200'})); // Cor Q1, 120 min
      }
      // Add a demo goal
      createCard({ text: "Definir meta principal da semana", when: `${getActiveDay()}TGOAL`, timerTotal: '900' }); // 15 min

    });
    applyFilters(); // Apply filters first
    updateSlotsHasItems(); // Then render the agenda based on filtered items
    updateTotalTimerDisplay(); // Initial total time calculation
  }


  function initApp() {
    ensureMatrix();
    ensureSchedule(false); // Create schedule structure
    loadState(); // Load collapsed states
    try{
        var raw=localStorage.getItem(LS_KEY);
        if(raw){
             var d=JSON.parse(raw);
             var dataToRestore = Array.isArray(d.data) ? d.data : d;
             if(Array.isArray(dataToRestore) && dataToRestore.length){
                 // Restore logic needs to handle putting cards into allCards cache
                 // and then letting updateSlotsHasItems render the agenda
                 restore(dataToRestore);
                 pushHistory(dataToRestore); // Push the raw data structure
                 updateTotalTimerDisplay(); // Calculate total after restore
                 return;
            }
        }
    }catch(e){ console.error("Error loading data:", e); }
    // If load failed or no data, init demo
    initDemo();
    pushHistory(serialize()); // Push initial state
    // updateTotalTimerDisplay(); // Already called in initDemo -> applyFilters -> updateSlotsHasItems
  }


  // ===== Restauração (undo/redo/import) =====
  function restore(data){
    if(!data||!data.length){ return; }
    allCards = []; // Clear the cache first

    // Clear visible lists in DOM
    $$('.list[data-type="kanban"] .cards', boardEl).forEach(c => c.innerHTML = '');
    $$('.list[data-type="quad"] .cards', matrixEl).forEach(c => c.innerHTML = '');
    $$('.list[data-type="goal"] .cards, .list[data-type="time"] .cards', schedule).forEach(c => c.innerHTML = '');

    var kanbanLists = {}, quadMap = {};
    $$('.list[data-type="kanban"]', boardEl).forEach(function(l) { kanbanLists[l.querySelector('.title').value] = l.querySelector('.cards'); });
    if(matrixEl) {
      quadMap = { Q1:matrixEl.querySelector('.list[data-quad="Q1"] .cards'), Q2:matrixEl.querySelector('.list[data-quad="Q2"] .cards'), Q3:matrixEl.querySelector('.list[data-quad="Q3"] .cards'), Q4:matrixEl.querySelector('.list[data-quad="Q4"] .cards') };
    }
    // No need for timeMap, updateSlotsHasItems handles agenda rendering

    function appendCardsToDOM(container, cardsData){
      if(!container || !cardsData || !cardsData.length) return;
      var fragment = document.createDocumentFragment();
      cardsData.forEach(function(cd){
           const cardEl = createCard(cd); // Adds to allCards cache
           fragment.appendChild(cardEl);
      });
      container.appendChild(fragment);
    }

    var existingKanbanTitles = new Set(Object.keys(kanbanLists));

    data.forEach(function(entry){
      if(entry.type==='kanban'){
        if (kanbanLists[entry.title]) {
            appendCardsToDOM(kanbanLists[entry.title], entry.cards);
            existingKanbanTitles.delete(entry.title);
        } else {
            var l = createList(entry.title || 'Lista');
            appendCardsToDOM(l.querySelector('.cards'), entry.cards);
        }
      } else if(entry.type==='quad' && quadMap[entry.quad]){
        appendCardsToDOM(quadMap[entry.quad], entry.cards);
      } else if(entry.type==='time' || entry.type === 'goal'){
        // Add to cache only, updateSlotsHasItems will render
        (entry.cards || []).forEach(cardData => {
            // Ensure 'when' is correctly formatted or assigned for goals
            if (entry.goal && cardData.when && !cardData.when.endsWith('TGOAL')) {
                 cardData.when = (cardData.when.split('T')[0] || getActiveDay()) + 'TGOAL'; // Ensure date part exists
            } else if (entry.time && cardData.when && !cardData.when.includes('T'+entry.time)) {
                // Fix potential mismatch if time is stored separately
                 cardData.when = (cardData.when.split('T')[0] || getActiveDay()) + 'T' + entry.time; // Ensure date part exists
            }
             createCard(cardData); // Adds to allCards cache
        });
      }
    });

    // Remove any empty Kanban lists that weren't in the data
    existingKanbanTitles.forEach(title => {
        const listToRemove = $$('.list[data-type="kanban"]', boardEl).find(l => l.querySelector('.title').value === title);
        if (listToRemove && listToRemove.querySelectorAll('.card').length === 0) {
            listToRemove.remove();
        }
    });


    applyFilters(); // Apply general filters (color, date range, time estimate)
    updateSlotsHasItems(); // Render the agenda for the current day
    updateTotalTimerDisplay(); // Update total time after restore
  }


  // ===== Cartões =====
  function updateTimerDisplay(card) {
      var disp = card.querySelector('.timer-display');
      if (!disp) return;
      var totalSeconds = parseInt(card.dataset.timerTotal || '0', 10);

      if (totalSeconds > 0) {
          var state = card.dataset.timerState || 'stopped';
          var seconds = parseInt(card.dataset.timerLeft, 10);
          if (isNaN(seconds)) seconds = totalSeconds;

          var mins = Math.floor(seconds / 60);
          var secs = seconds % 60;
          disp.textContent = `⏱️ ${to2(mins)}:${to2(secs)}`;

          if (state === 'running') { disp.style.color = '#66bb6a'; disp.style.background = 'rgba(102, 187, 106, 0.2)'; } // green
          else if (state === 'paused') { disp.style.color = '#ffa726'; disp.style.background = 'rgba(255, 167, 38, 0.2)'; } // orange
          else if (state === 'finished') { disp.style.color = '#ef5350'; disp.style.background = 'rgba(239, 83, 80, 0.2)'; } // red
          else { // stopped
             var totalMins = Math.round(totalSeconds / 60);
             disp.textContent = `⏳ ${totalMins} min`; // Changed 'm' to ' min'
             disp.style.color = ''; disp.style.background = 'rgba(0,0,0,.2)';
          }
      } else {
          disp.textContent = '';
      }
  }

  function paintCard(c){
    var color = c.dataset.color || '';
    if (color) { c.style.borderColor = color; c.style.borderLeftColor = color; }
    else { c.style.borderColor = '#20486f'; c.style.borderLeftColor = 'transparent'; }
    var dot=c.querySelector('.dot'); if(dot) dot.style.background=color||'transparent';
    updateTimerDisplay(c);
  }

  function createCard(data){
    var _d= (typeof data==='string')? {text:data} : (data||{text:''});
    var c=el('div','card'); c.draggable=true;
    c.dataset.color=_d.color||''; c.dataset.due=_d.due||''; c.dataset.when=_d.when||'';
    c.dataset.timerTotal = _d.timerTotal || ''; c.dataset.timerLeft = _d.timerLeft || _d.timerTotal || ''; c.dataset.timerState = _d.timerState || 'stopped';

    var t=el('span','text'); t.textContent=_d.text||'';
    var meta=el('div','meta'); var dot=el('span','dot'); var timerDisp=el('span','timer-display'); meta.appendChild(dot); meta.appendChild(timerDisp);
    var kb=el('button','kebab'); kb.type='button'; kb.textContent='⋮';
    kb.addEventListener('click',function(ev){ ev.stopPropagation(); clearSelection(); addSelection(c); var r=kb.getBoundingClientRect(); showCtx(r.right,r.bottom,c); });
    c.appendChild(t); c.appendChild(meta); c.appendChild(kb); paintCard(c);

    c.addEventListener('mousedown',function(e){ if(e.button!==0) return; if(e.shiftKey){ rangeSelect(c); } else if(e.ctrlKey||e.metaKey){ toggleSelection(c); } else if(!selected.has(c)) { clearSelection(); addSelection(c); } updateTotalTimerDisplay(); }); // Update timer on selection change
    c.addEventListener('dragstart',function(e){ e.stopPropagation(); var block = selected.has(c)? Array.from(selected) : [c]; dragState={leader:c, block:block}; block.forEach(function(n){ n.classList.add('dragging'); }); pushPH(); try{e.dataTransfer.setData('text/plain','drag'); e.dataTransfer.effectAllowed='move';}catch(_){} });
    c.addEventListener('dragend',function(){ if(dragState&&dragState.block){ dragState.block.forEach(function(n){ n.classList.remove('dragging'); }); } cleanupPH(); dragState=null; persist(); updateSlotsHasItems(); updateTotalTimerDisplay(); }); // Update timer after drag
    c.addEventListener('contextmenu',function(e){ e.preventDefault(); if(!selected.has(c)){ clearSelection(); addSelection(c);} showCtx(e.clientX,e.clientY,c); });
    c.addEventListener('dblclick',function(e){ e.preventDefault(); handleCardDblClick(c); });

    // Add to cache only if it doesn't already exist (important for restore)
    if (!allCards.includes(c)) {
        allCards.push(c);
    }
    updateTotalTimerDisplay(); // Update total when adding card
    return c;
  }

  function removeCard(c) {
      var index = allCards.indexOf(c);
      if (index > -1) allCards.splice(index, 1);
      c.remove();
      persist(); // Persist after removing from cache and DOM
      updateSlotsHasItems(); // Update agenda display if it was an agenda card
      updateTotalTimerDisplay(); // Update total after removing
  }


  function startInlineEdit(card){
    var tEl=card.querySelector('.text'); if(!tEl) return; if(card.classList.contains('editing')) return;
    card.classList.add('editing'); var original=tEl.textContent; tEl.setAttribute('contenteditable','true'); tEl.focus();
    // Move cursor to end
    var sel=window.getSelection();
    var range=document.createRange();
    range.selectNodeContents(tEl);
    range.collapse(false); // false collapses to the end
    sel.removeAllRanges();
    sel.addRange(range);

    function finish(save){
        tEl.removeEventListener('keydown',onKey);
        tEl.removeEventListener('blur',onBlur);
        tEl.removeAttribute('contenteditable');
        card.classList.remove('editing');
        if(!save) {
            tEl.textContent=original;
        } else if (tEl.textContent.trim() === '') {
            removeCard(card); // Remove card if text is empty after edit
        }
        persist();
    }
    function onKey(ev){
        if(ev.key==='Escape'){
            ev.preventDefault();
            finish(false);
        }
        // Save on Enter or Ctrl+Enter/Meta+Enter
        if(ev.key==='Enter' && !ev.shiftKey){ // Allow Shift+Enter for new lines
            ev.preventDefault();
            finish(true);
        }
    }
    function onBlur(){ finish(true); }
    tEl.addEventListener('keydown',onKey);
    tEl.addEventListener('blur',onBlur);
  }


  // ===== Timer Logic =====
  function startGlobalTimer() {
      if (globalTimerInterval) return;
      globalTimerInterval = setInterval(function() {
          var activeTimers = false;
          allCards.forEach(function(c) {
              if (c.dataset.timerState === 'running') {
                  activeTimers = true;
                  var now = Date.now();
                  var end = parseInt(c.dataset.timerEnd, 10);
                  var left = Math.round((end - now) / 1000);
                  if (left <= 0) {
                      c.dataset.timerState = 'finished';
                      c.dataset.timerLeft = 0;
                      c.style.animation = 'flash 1s 3';
                  } else {
                      c.dataset.timerLeft = left;
                  }
                  updateTimerDisplay(c);
              }
          });
          if (!activeTimers) {
              clearInterval(globalTimerInterval);
              globalTimerInterval = null;
          }
      }, 1000);
  }

  function handleCardDblClick(c) {
      var state = c.dataset.timerState || 'stopped';
      var total = parseInt(c.dataset.timerTotal || '0', 10);
      if (total === 0) {
          startInlineEdit(c);
          return;
      }

      if (state === 'running') { // Pause
          c.dataset.timerState = 'paused';
          var now = Date.now();
          var end = parseInt(c.dataset.timerEnd, 10);
          c.dataset.timerLeft = Math.round((end - now) / 1000);
      } else { // Start or resume
          c.dataset.timerState = 'running';
          var left = parseInt(c.dataset.timerLeft, 10);
          if (state === 'finished' || left <= 0) left = total;
          c.dataset.timerEnd = Date.now() + left * 1000;
          c.style.animation = ''; // remove flash animation if it was there
          startGlobalTimer();
      }
      updateTimerDisplay(c);
      persist();
  }

  // ===== DnD =====
  var dragState=null; var draggingList=null; var lastAnchor=null; // `selected` moved to top
  function clearSelection(){ selected.forEach(function(c){c.classList.remove('selected');}); selected.clear(); updateTotalTimerDisplay();} // Update timer on clear
  function addSelection(c){ if(!selected.has(c)){ selected.add(c); c.classList.add('selected'); lastAnchor=c; } updateTotalTimerDisplay(); } // Update timer on add
  function toggleSelection(c){ if(selected.has(c)){ selected.delete(c); c.classList.remove('selected'); } else { addSelection(c);} updateTotalTimerDisplay(); } // Update timer on toggle
  function rangeSelect(to){ if(!lastAnchor){ addSelection(to); return; } var parent=lastAnchor.parentElement; if(to.parentElement!==parent){ addSelection(to); return;} var cards=[].slice.call(parent.querySelectorAll('.card')); var a=cards.indexOf(lastAnchor); var b=cards.indexOf(to); var i=a<b?a:b; var j=a<b?b:a; clearSelection(); for(var k=i;k<=j;k++){ if(cards[k].style.display !== 'none') addSelection(cards[k]); } updateTotalTimerDisplay(); } // Update timer after range select
  function getSelectionOr(target){ return selected.size? Array.from(selected) : (target? [target] : []); }
  function pushPH(){ if(!dragState) dragState={}; var ph=el('div','placeholder'); dragState.placeholder=ph; return ph; }
  function cleanupPH(){ if(dragState&&dragState.placeholder) dragState.placeholder.remove(); }
  function nearestAfter(container,y){ var els=[].slice.call(container.querySelectorAll('.card:not(.dragging)')); var best={offset:-Infinity,element:null}; els.forEach(function(child){ var r=child.getBoundingClientRect(); var o=y-(r.top+r.height/2); if(o<0 && o>best.offset) best={offset:o,element:child}; }); return best.element; }

  function wireDropZone(container){
    var isSlot = container.classList.contains('slot') || container.classList.contains('goal-slot'); // Include goal slot
    var cardsContainer = isSlot ? container.querySelector('.cards') : container;

    function handleDrop(e) {
      if(!dragState) return;
      e.preventDefault(); e.stopPropagation();

      var parent = dragState.placeholder.parentElement || cardsContainer;
      var ref = dragState.placeholder;
      var block = (dragState.block && dragState.block.length) ? dragState.block : [dragState.leader];

      // Important: Update dataset.when BEFORE moving nodes in the DOM cache
      applyWhen(container, block); // Update 'when' attribute in the cache

      // Now physically move elements in the DOM (needed for Kanban/Matrix)
      if (!isSlot) {
         block.forEach(function(n){ parent.insertBefore(n, ref); });
      }

      if(dragState.block){ dragState.block.forEach(function(n){ n.classList.remove('dragging'); }); }
      cleanupPH();
      if (isSlot) container.classList.remove('hover');
      dragState=null;

      // Refresh agenda view after drop and persist changes
      updateSlotsHasItems();
      persist();
      updateTotalTimerDisplay(); // Update total after drop potentially changes visibility
    }

    function handleDragOver(e) {
      if(!dragState) return;
      e.preventDefault();
      // Only append placeholder in the DOM, actual card adding is on drop
      var after = nearestAfter(cardsContainer, e.clientY);
      var ph = dragState.placeholder;
      if (!after) cardsContainer.appendChild(ph);
      else cardsContainer.insertBefore(ph, after);
      if (isSlot) container.classList.add('hover');
    }

    container.addEventListener('dragover', handleDragOver);
    container.addEventListener('drop', handleDrop);
    if (isSlot) {
        container.addEventListener('dragleave', function() { container.classList.remove('hover'); });
    }
  }

  function applyWhen(listElement, nodes){
    const day = getActiveDay();
    let targetWhen = '';

    if(listElement && listElement.dataset.type === 'time'){
      targetWhen = day + 'T' + listElement.dataset.time;
    } else if (listElement && listElement.dataset.type === 'goal') {
      targetWhen = day + 'TGOAL';
    } else {
      // Dropped outside agenda, clear 'when'
      targetWhen = '';
    }

    nodes.forEach(function(n){
        // Update the actual card element in the cache (allCards)
        const cardInCache = allCards.find(card => card === n);
        if (cardInCache) {
            cardInCache.dataset.when = targetWhen;
        } else {
            // This case should ideally not happen if createCard always adds to cache
            console.warn("Dragged card not found in cache:", n);
            n.dataset.when = targetWhen; // Update DOM node as fallback
        }
    });

    // Don't call updateSlotsHasItems here, call it after drop completes
  }


  boardEl.addEventListener('dragover',function(e){ if(!draggingList) return; e.preventDefault(); var after=listAfter(boardEl,e.clientX); if(after==null) boardEl.appendChild(draggingList); else boardEl.insertBefore(draggingList,after); });
  function listAfter(container,x){ var els=[].slice.call(container.querySelectorAll('.list:not(.dragging)')); var best={offset:-Infinity,element:null}; els.forEach(function(ch){ var r=ch.getBoundingClientRect(); var o=x-(r.left+r.width/2); if(o<0&&o>best.offset) best={offset:o,element:ch}; }); return best.element; }

  // ===== Listas =====
  function createList(title){
    var list = el('section','list');
    list.dataset.type='kanban';
    var h=el('header');
    var t=el('input','title');
    t.value=title||'Nova lista';
    var more=el('button','more');
    more.type='button'; more.textContent='⋯';
    more.addEventListener('click',function(ev){ ev.stopPropagation(); var r=more.getBoundingClientRect(); showListCtx(r.right,r.bottom,list); });
    h.appendChild(t); h.appendChild(more);
    list.appendChild(h);
    var cards=el('div','cards');
    list.appendChild(cards);
    wireDropZone(cards); // Wire the inner cards container for kanban/matrix
    var add=el('div','add');
    var form=el('form');
    form.className='row';
    form.setAttribute('autocomplete','off');
    var input=el('input');
    input.type='text';
    input.placeholder='Novo cartão…';
    input.setAttribute('enterkeyhint','go');
    function addCard(){ var v=(input.value||'').trim(); if(!v) return; var card=createCard({text:v}); cards.appendChild(card); input.value=''; input.focus(); persist(); /* updateTotalTimerDisplay called in createCard */}
    form.addEventListener('submit',function(e){ e.preventDefault(); addCard(); });
    form.appendChild(input);
    add.appendChild(form);
    list.appendChild(add);
    boardEl.appendChild(list);
    h.draggable=true;
    h.addEventListener('dragstart',function(ev){ draggingList=list; list.classList.add('dragging'); if(ev.dataTransfer) ev.dataTransfer.setData('text/plain','list'); });
    h.addEventListener('dragend',function(){ draggingList=null; list.classList.remove('dragging'); persist(); });
    h.addEventListener('contextmenu',function(e){ e.preventDefault(); showListCtx(e.clientX,e.clientY,list); });
    return list;
  }

  // ===== Matriz =====
  function ensureMatrix(){
    matrixEl.innerHTML = ''; // Clear previous content to be safe

    var corner=el('div','axis corner');
    corner.style.gridArea = '1 / 1';
    matrixEl.appendChild(corner);

    var axX1=el('div','axis'); axX1.textContent='URGENTE';
    axX1.style.gridArea = '1 / 2';
    matrixEl.appendChild(axX1);

    var axX2=el('div','axis'); axX2.textContent='NÃO URGENTE';
    axX2.style.gridArea = '1 / 3';
    matrixEl.appendChild(axX2);

    var axY1=el('div','axis axis-y'); axY1.textContent='IMPORTANTE';
    axY1.style.gridArea = '2 / 1';
    matrixEl.appendChild(axY1);

    var axY2=el('div','axis axis-y'); axY2.textContent='NÃO IMPORTANTE';
    axY2.style.gridArea = '3 / 1';
    matrixEl.appendChild(axY2);

    var specs=[
        {quad:'Q1',label:'FAÇA AGORA', area: '2 / 2'},
        {quad:'Q2',label:'AGENDE', area: '2 / 3'},
        {quad:'Q3',label:'DELEGUE', area: '3 / 2'},
        {quad:'Q4',label:'ELIMINE', area: '3 / 3'}
    ];
    specs.forEach(function(sp){
      var l=el('section','list');
      l.dataset.type='quad';
      l.dataset.quad=sp.quad;
      l.style.gridArea = sp.area;

      var h=el('header');
      var t=el('div','quad-label');
      t.textContent=sp.label;
      h.appendChild(t);

      var cs=el('div','cards');
      wireDropZone(cs); // Wire cards container
      l.appendChild(h);
      l.appendChild(cs);
      matrixEl.appendChild(l);
    });
  }

  // ===== Agenda =====
  function ensureSchedule(){
     if (slotsRoot.querySelector('.goal-slot')) return; // Already created including goal slot

     // Add Goal Slot first
     var goalSlot = el('section', 'list goal-slot'); // Changed class for styling
     goalSlot.dataset.type = 'goal'; // Use 'goal' type
     var goalHead = el('div', 'head');
     var goalLabel = el('span', 'goal-label'); // Changed class for styling
     goalLabel.textContent = '🎯 OBJETIVO DO DIA';
     goalHead.appendChild(goalLabel);
     goalSlot.appendChild(goalHead);
     var goalCards = el('div', 'cards');
     goalSlot.appendChild(goalCards);
     wireDropZone(goalSlot); // Wire the entire goal slot
     slotsRoot.appendChild(goalSlot);

    // Add Time Slots starting from 6:00
    for(var h=6; h<=23; h++){ // Start loop from h=6
      for(var m=0; m<=30; m+=30){
        if(h===23 && m===30) break;
        var t=to2(h)+':'+to2(m);
        var slot=el('section','list slot');
        slot.dataset.type='time';
        slot.dataset.time=t;
        var head=el('div','head');
        var label=el('span','time');
        label.textContent=t;
        head.appendChild(label);
        slot.appendChild(head);
        var cards=el('div','cards');
        slot.appendChild(cards);
        wireDropZone(slot); // Wire the entire time slot
        slotsRoot.appendChild(slot);
      }
    }
    var date=document.getElementById('agendaDate');
    if(date&&!date.value){ date.value=new Date().toISOString().slice(0,10); }
  }

  function copyAgendaFrom(fromDay, toDay) {
    if (fromDay === toDay) return;
    const dayPrefix = fromDay + 'T';
    allCards.forEach(function(c) {
        if ((c.dataset.when || '').startsWith(dayPrefix)) {
            const timeOrGoal = (c.dataset.when || '').substring(11); // "HH:MM" or "GOAL"
            const newData = cardToData(c);
            newData.when = toDay + 'T' + timeOrGoal;
            createCard(newData); // Add the copied card to the main cache
        }
    });
    updateSlotsHasItems(); // Refresh the agenda view for the 'toDay'
    persist();
    updateTotalTimerDisplay(); // Update total after copying
  }

  function getActiveDay(){ var i=document.getElementById('agendaDate'); return (i&&i.value)?i.value:new Date().toISOString().slice(0,10); }

  // Renders the agenda based on allCards cache and selected date
  function updateSlotsHasItems() {
    const day = getActiveDay();
    const dayPrefixGoal = day + 'TGOAL';
    const dayPrefixTime = day + 'T';
    const visibleCardsInSlots = new Set(); // Keep track of cards shown in agenda

    // Clear and refill Goal slot
    const goalSlot = slotsRoot.querySelector('.goal-slot');
    const goalCardsContainer = goalSlot.querySelector('.cards');
    goalCardsContainer.innerHTML = ''; // Clear previous cards
    let goalHasVisible = false;
    allCards.forEach(card => {
        if (card.dataset.when === dayPrefixGoal && cardPassesFilters(card)) {
            goalCardsContainer.appendChild(card); // Append card element from cache
            goalHasVisible = true;
            visibleCardsInSlots.add(card);
        }
    });
    goalSlot.classList.toggle('has-items', goalHasVisible);

    // Clear and refill Time slots
    $$('.list.slot', schedule).forEach(function(slot) {
        const time = slot.dataset.time;
        const cardsContainer = slot.querySelector('.cards');
        cardsContainer.innerHTML = ''; // Clear previous cards
        let slotHasVisible = false;
        const targetWhen = dayPrefixTime + time;

        allCards.forEach(card => {
            if (card.dataset.when === targetWhen && cardPassesFilters(card)) {
                cardsContainer.appendChild(card); // Append card element from cache
                slotHasVisible = true;
                visibleCardsInSlots.add(card);
            }
        });
        slot.classList.toggle('has-items', slotHasVisible);
    });

     // Hide cards in Kanban/Matrix if they are shown in the agenda for the current day
     $$('.board .card, .matrix .card').forEach(card => {
         if (visibleCardsInSlots.has(card)) {
             card.style.display = 'none';
         } else if (cardPassesFilters(card)) { // Check general filters otherwise
             card.style.display = '';
         } else {
             card.style.display = 'none';
         }
     });
     updateTotalTimerDisplay(); // Update total after visibility changes
  }


  // ===== Filtros =====
  var selectedColors=new Set();
  function parseTime(timeStr) {
      if (!timeStr) return 0;
      var totalMinutes = 0;
      var hoursMatch = timeStr.match(/(\d+)\s*h/);
      var minutesMatch = timeStr.match(/(\d+)\s*m/);
      if (hoursMatch) totalMinutes += parseInt(hoursMatch[1], 10) * 60;
      if (minutesMatch) totalMinutes += parseInt(minutesMatch[1], 10);
      if (!hoursMatch && !minutesMatch && /^\d+$/.test(timeStr)) {
          totalMinutes = parseInt(timeStr, 10);
      }
      return totalMinutes;
  }
  // This checks filters *other than* date matching for agenda
  function cardPassesFilters(c){
    var fFrom=(document.getElementById('fFrom').value)||'';
    var fTo=(document.getElementById('fTo').value)||'';
    var fTime = document.getElementById('fTime').value;
    var ok=true;
    if(selectedColors.size>0){ ok= ok && selectedColors.has((c.dataset.color||'').toLowerCase()); }
    if(fFrom){ ok = ok && (!!c.dataset.due && c.dataset.due>=fFrom); }
    if(fTo){ ok = ok && (!!c.dataset.due && c.dataset.due<=fTo); }
    if(fTime) {
      var maxMins = parseTime(fTime);
      var cardMins = Math.round(parseInt(c.dataset.timerTotal || '0', 10) / 60);
      ok = ok && (cardMins > 0 && cardMins <= maxMins);
    }
    return ok;
  }

  // Applies general filters AND triggers agenda refresh for the current date
  function applyFilters(){
    // Update non-agenda cards based on filters
    let visibleCount = 0;
    allCards.forEach(function(c){
       const passesGeneralFilters = cardPassesFilters(c);
       // We only hide/show non-agenda cards here. Agenda cards are handled by updateSlotsHasItems
       if (!c.dataset.when || !c.dataset.when.includes('T')) {
          c.style.display = passesGeneralFilters ? '' : 'none';
       }
       if (passesGeneralFilters) {
           visibleCount++; // Count all potentially visible cards
       }
    });

    updateSlotsHasItems(); // Refresh agenda based on current date AND general filters
    updateFiltersUi(allCards.length, $$('.card[style*="display: none"]').length); // Update UI based on hidden cards count
    updateTotalTimerDisplay(); // Update total after filtering
  }


  // ===== Menus =====
  var ctxTarget=null; var ctx=document.getElementById('ctx'); var ctxMoveSub=document.getElementById('ctx-move-sub'); var ctxMoveAllSub=document.getElementById('ctx-moveall-sub');
  var listCtxTarget=null; var listCtx=document.getElementById('ctx-list'); var listMoveSub=document.getElementById('ctx-list-move-sub');
  function hideCtx(){ ctx.style.display='none'; ctxTarget=null; ctxMoveSub.style.display='none'; ctxMoveAllSub.style.display='none'; }
  function showCtx(x,y,card){ ctxTarget=card; buildMoveSubmenu(); ctxMoveSub.style.display='none'; ctxMoveAllSub.style.display='none'; ctx.style.display='block'; var r=ctx.getBoundingClientRect(); ctx.style.left=Math.min(x,innerWidth-r.width-8)+'px'; ctx.style.top=Math.min(y,innerHeight-r.height-8)+'px'; }

  function isAnyFilterActive(){
      return selectedColors.size>0 || !!document.getElementById('fFrom').value || !!document.getElementById('fTo').value || !!document.getElementById('fTime').value;
  }
 function updateFiltersUi(totalCards, hiddenCardsCount){ // Changed parameter
      var badge=document.getElementById('filtersOn');
      var header=document.getElementById('appHeader');
      if(isAnyFilterActive()){
          // Use the count of actually hidden cards
          badge.textContent = hiddenCardsCount > 0 ? ('Filtros: '+hiddenCardsCount+' oculto'+(hiddenCardsCount>1?'s':'')) : 'Filtros ativos';
          badge.hidden=false;
          header.classList.add('filters-active');
      } else {
          // If no filters are active, ensure all cards are visible (except potentially agenda cards for other days)
          allCards.forEach(c => {
               if (!c.dataset.when || !c.dataset.when.includes('T')) { // Only touch non-agenda cards here
                    c.style.display = '';
               }
          });
          updateSlotsHasItems(); // Refresh agenda to ensure cards for the day are shown
          badge.hidden=true;
          header.classList.remove('filters-active');
          // Recalculate hidden count *after* potentially showing cards again
          hiddenCardsCount = $$('.card[style*="display: none"]').length;
      }
       // Update badge based on final hidden count even if filters are cleared
       if (hiddenCardsCount > 0 && !isAnyFilterActive()) {
            // This happens if cards are hidden only because they belong to another day's agenda
            badge.textContent = `Agenda: ${hiddenCardsCount} oculto${hiddenCardsCount > 1 ? 's' : ''}`;
            badge.hidden = false;
        } else if (!isAnyFilterActive()) {
            badge.hidden = true;
        }
  }


  function buildMoveSubmenu(){
    ctxMoveSub.innerHTML = '';
    // Add Kanban lists
    $$('.list[data-type="kanban"]', boardEl).forEach(function(l, i){
        addMoveButton(l, (l.querySelector('.title') ? l.querySelector('.title').value : null) || ('Lista ' + (i + 1)), ctxMoveSub);
    });
    // Add Matrix quadrants
    $$('.list[data-type="quad"]', matrixEl).forEach(function(l){
        addMoveButton(l, l.dataset.quad, ctxMoveSub);
    });
     // Add Goal slot
    const goalSlot = slotsRoot.querySelector('.goal-slot');
    if (goalSlot) addMoveButton(goalSlot, '🎯 OBJETIVO DO DIA', ctxMoveSub);
    // Add Time slots
    $$('.list[data-type="time"]', schedule).forEach(function(l){
        addMoveButton(l, l.dataset.time, ctxMoveSub);
    });
}

function addMoveButton(targetListElement, name, submenuContainer) {
    var b = el('button');
    b.textContent = name;
    b.addEventListener('click', function(ev) {
        ev.stopPropagation();
        var block = getSelectionOr(ctxTarget);
        if (!block.length) return;

        var destContainer = targetListElement.querySelector('.cards') || targetListElement; // Target the .cards div or the element itself
        var isAgendaDrop = targetListElement.closest('#agenda-sidebar');

        // Update data-when attribute first
        applyWhen(targetListElement, block);

        // Move elements in DOM only if NOT dropping into agenda
        if (!isAgendaDrop) {
            block.forEach(function(cardElement) {
                destContainer.appendChild(cardElement); // Move to new non-agenda list
            });
        }

        updateSlotsHasItems(); // Refresh agenda view
        persist();
        applyFilters(); // Re-apply general filters
        hideCtx();
    });
    submenuContainer.appendChild(b);
}


  function buildMoveAllSubmenu(fromList){
      ctxMoveAllSub.innerHTML = '';
      const sourceCardsContainer = fromList.querySelector('.cards');
      if (!sourceCardsContainer) return;

      $$('.list').forEach(function(l, i){
          if(l === fromList) return; // Don't move to self
          addMoveAllButton(l, (l.querySelector('.title') ? l.querySelector('.title').value : null) || l.dataset.quad || l.dataset.time || ('Lista ' + (i + 1)), ctxMoveAllSub, fromList);
      });
       // Add Goal slot specifically if it exists
      const goalSlot = slotsRoot.querySelector('.goal-slot');
      if (goalSlot && goalSlot !== fromList) {
           addMoveAllButton(goalSlot, '🎯 OBJETIVO DO DIA', ctxMoveAllSub, fromList);
      }
  }

function addMoveAllButton(targetListElement, name, submenuContainer, sourceListElement) {
    var b = el('button');
    b.textContent = name;
    b.addEventListener('click', function(ev) {
        ev.stopPropagation();
        const sourceCardsContainer = sourceListElement.querySelector('.cards');
        if (!sourceCardsContainer) return;

        const cardsToMove = Array.from(sourceCardsContainer.querySelectorAll('.card'));
        if (!cardsToMove.length) return;

        var destContainer = targetListElement.querySelector('.cards') || targetListElement;
        var isAgendaDrop = targetListElement.closest('#agenda-sidebar');

        // Update data-when attribute first
        applyWhen(targetListElement, cardsToMove);

        // Move elements in DOM only if NOT dropping into agenda
        if (!isAgendaDrop) {
            cardsToMove.forEach(function(cardElement) {
                destContainer.appendChild(cardElement); // Move to new non-agenda list
            });
        } else {
             // If moving to agenda, remove from original DOM list
             cardsToMove.forEach(c => c.remove());
        }

        updateSlotsHasItems(); // Refresh agenda view
        persist();
        applyFilters(); // Re-apply general filters
        hideCtx();
    });
    submenuContainer.appendChild(b);
}

  ctx.addEventListener('click',function(e){ var btn=e.target.closest('button'); if(!btn) return; var action=btn.dataset.action; var block=getSelectionOr(ctxTarget);
    if(action==='move'){ ctxMoveSub.style.display=(ctxMoveSub.style.display==='block'?'none':'block'); ctxMoveAllSub.style.display='none'; return; }
    if(action==='move-all'){ var list=(ctxTarget||block[0])? (ctxTarget||block[0]).closest('.list'):null; if(!list) return; buildMoveAllSubmenu(list); ctxMoveAllSub.style.display=(ctxMoveAllSub.style.display==='block'?'none':'block'); ctxMoveSub.style.display='none'; return; }
    hideCtx();
    if(action==='gemini-subtasks'){ generateSubtasks(block); }
    else if(action==='gemini-organize'){ organizeCardWithGemini(block); }
    else if(action==='dup'){ duplicateCards(block); }
    else if(action==='del'){ block.forEach(function(n){ removeCard(n); }); /* Persist is called within removeCard */ }
    else if(action==='color'){ openColorDialog(block); }
    else if(action==='date'){ openDateDialog(block); }
    else if(action==='timer'){ openTimerDialog(block); }
    else if(action==='del-all'){ var list2=(ctxTarget||block[0])? (ctxTarget||block[0]).closest('.list'):null; if(!list2) return; showConfirm('Excluir TODOS os cartões desta lista?',function(){ $$('.card',list2).forEach(function(c){ removeCard(c); }); /* Persist is called within removeCard */ }); }
  });

  function showListCtx(x,y,list){ listCtxTarget=list; buildListMoveSub(); listMoveSub.style.display='none'; listCtx.style.display='block'; var r=listCtx.getBoundingClientRect(); listCtx.style.left=Math.min(x,innerWidth-r.width-8)+'px'; listCtx.style.top=Math.min(y,innerHeight-r.height-8)+'px'; }
  function buildListMoveSub(){
      listMoveSub.innerHTML = '';
      if (!listCtxTarget) return;

       $$('.list').forEach(function(l, i){
          if(l === listCtxTarget) return; // Don't move to self
          addMoveAllButton(l, (l.querySelector('.title') ? l.querySelector('.title').value : null) || l.dataset.quad || l.dataset.time || ('Lista ' + (i + 1)), listMoveSub, listCtxTarget);
      });
       // Add Goal slot specifically if it exists
      const goalSlot = slotsRoot.querySelector('.goal-slot');
      if (goalSlot && goalSlot !== listCtxTarget) {
           addMoveAllButton(goalSlot, '🎯 OBJETIVO DO DIA', listMoveSub, listCtxTarget);
      }
  }

  listCtx.addEventListener('click',function(e){ var b=e.target.closest('button'); if(!b) return; var action=b.dataset.action; if(action==='list-move-all'){ listMoveSub.style.display=(listMoveSub.style.display==='block'?'none':'block'); return; } if(action==='list-del'&&listCtxTarget){ showConfirm('Excluir a lista inteira?',function(){ listCtxTarget.remove(); persist(); }); } listCtx.style.display='none'; });

  // ===== Modal helpers + Paleta =====
  var MATRIX_COLORS = { Q1:'#104239', Q2:'#0e3155', Q3:'#5a4014', Q4:'#5a1419' };
  var EXTRA_COLORS = [{id:'krav', name:'Azul claro (Krav Maga)', hex:'#5dade2'},{id:'gdf', name:'Amarelo claro (GDF)', hex:'#f9e79f'},{id:'pessoal', name:'Laranja (Pessoal)', hex:'#f5b041'},{id:'teal', name:'Verde-água', hex:'#1abc9c'},{id:'lilas', name:'Lilás', hex:'#8e44ad'},{id:'navy', name:'Azul escuro', hex:'#1f3a93'},{id:'grafite', name:'Grafite', hex:'#2c3e50'},{id:'turquesa', name:'Turquesa', hex:'#48c9b0'}];
  function buildFullPalette(){ return [{id:'q1',name:'Verde (Faça agora)',hex:MATRIX_COLORS.Q1},{id:'q2',name:'Azul (Agende)',hex:MATRIX_COLORS.Q2},{id:'q3',name:'Âmbar (Delegue)',hex:MATRIX_COLORS.Q3},{id:'q4',name:'Vermelho (Elimine)',hex:MATRIX_COLORS.Q4}].concat(EXTRA_COLORS); }
  function routeByColor(card, hex){ if(!hex||!matrixEl) return; var map={}; map[MATRIX_COLORS.Q1]='Q1'; map[MATRIX_COLORS.Q2]='Q2'; map[MATRIX_COLORS.Q3]='Q3'; map[MATRIX_COLORS.Q4]='Q4'; var quad=map[(hex||'').toLowerCase()]; if(!quad) return; var dest=matrixEl.querySelector('.list[data-quad="'+quad+'"] .cards'); if(dest){ dest.appendChild(card); card.dataset.when=''; updateSlotsHasItems(); /* Update agenda if card moved from it */ } }
  function showModal(title,builder,onOk){
      var wrap=el('div','modal-wrap');
      var box=el('div','modal');
      var h=el('h3'); h.textContent=title; box.appendChild(h);
      var body=builder(); box.appendChild(body);
      var row=el('div','row');
      var cancel=el('button','cancel'); cancel.textContent='Cancelar';
      var ok=el('button','ok'); ok.textContent='OK';
      row.appendChild(cancel); row.appendChild(ok); box.appendChild(row);
      wrap.appendChild(box); document.body.appendChild(wrap);

      // Enter key listener for the modal
      const modalKeyListener = function(e) {
          if (e.key === 'Enter') {
              e.preventDefault();
              ok.click(); // Trigger the OK button click
          } else if (e.key === 'Escape') {
               e.preventDefault();
               cancel.click(); // Trigger Cancel on Escape
          }
      };
      wrap.setAttribute('tabindex', '-1'); // Make the modal focusable
      wrap.focus(); // Focus the modal itself
      wrap.addEventListener('keydown', modalKeyListener);

      cancel.onclick=function(){
          wrap.removeEventListener('keydown', modalKeyListener); // Clean up listener
          document.body.removeChild(wrap);
      };
      // Modified ok.onclick to pass the ok button itself to onOk
      ok.onclick=function(){
           wrap.removeEventListener('keydown', modalKeyListener); // Clean up listener
           onOk(body, ok); // Let onOk handle removal if needed, otherwise remove below
           // Ensure modal is removed if onOk doesn't handle it
           if (wrap.parentNode === document.body) {
               document.body.removeChild(wrap);
           }
      };
      var firstInput = body.querySelector('input'); if(firstInput) firstInput.focus();
      return { wrap: wrap, okButton: ok, cancelButton: cancel }; // Return wrap and buttons
  }

  function showConfirm(message,onYes){
      const { wrap, okButton, cancelButton } = showModal('Confirmação', function(){ var d=el('div'); d.textContent=message; return d; }, function(body, okBtn){ if(typeof onYes==='function') onYes(); /* Removal handled by default click */ });
      // No specific Enter handling needed here as showModal already adds it.
  }

  function openColorDialog(cards){ if(!cards.length) return; var PALETTE=[{id:'none',name:'Sem cor',hex:''}].concat(buildFullPalette()); showModal('Editar cor',function(){ var wrap=el('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='repeat(auto-fill, minmax(120px, 1fr))'; wrap.style.gap='8px'; PALETTE.forEach(function(p){ var b=el('button'); b.type='button'; b.style.border='1px solid #2a4e78'; b.style.borderRadius='8px'; b.style.padding='10px'; b.style.cursor='pointer'; b.style.background=p.hex||'#0b2240'; b.style.color='#fff'; b.textContent=p.name; b.addEventListener('click',function(){ [].slice.call(wrap.querySelectorAll('button')).forEach(function(x){x.style.outline='';}); b.style.outline='2px solid #fff'; wrap._chosen=p.hex; }); if(p.hex===(cards[0].dataset.color||'')) b.style.outline='2px solid #fff'; wrap.appendChild(b); }); return wrap; }, function(wrap, okBtn){ var v=(wrap._chosen===undefined)? (cards[0].dataset.color||'') : wrap._chosen; cards.forEach(function(c){ c.dataset.color=v||''; paintCard(c); routeByColor(c, v||''); }); applyFilters(); }); }
  function openDateDialog(cards){ if(!cards.length) return; showModal('Editar data',function(){ var r=el('div'); var i=el('input'); i.type='date'; if(cards[0].dataset.due) i.value=cards[0].dataset.due; r.appendChild(i); return r; }, function(r, okBtn){ var v=r.querySelector('input').value; cards.forEach(function(c){ c.dataset.due=v||''; }); applyFilters(); }); }
  function openTimerDialog(cards) {
      if (!cards.length) return;
      var modalElements = showModal('Definir Timer (minutos)', function() { // Capture return value
          var r = el('div');
          var timerVal = Math.round(parseInt(cards[0].dataset.timerTotal || '0', 10) / 60) || '';
          r.innerHTML = `
              <label style="display: block;">
                  Tempo para o timer (em minutos):
                  <input type="number" class="timer-input" placeholder="Ex: 25" value="${timerVal}" style="width:100%; padding:8px; background:#0b2240; border:1px solid #2a4e78; border-radius:8px; color:#fff; margin-top: 4px;">
              </label>
          `;
           // Enter key listener added directly within showModal now
          return r;
      }, function(r, okBtn) { // onOk receives the ok button
          var timerMins = r.querySelector('.timer-input').value;
          cards.forEach(function(c) {
              var newTotal = (parseInt(timerMins, 10) || 0) * 60;
              c.dataset.timerTotal = newTotal;
              c.dataset.timerLeft = newTotal;
              c.dataset.timerState = 'stopped';
              c.style.animation = ''; // Clear flash
              paintCard(c);
          });
          applyFilters();
          // Modal removal handled by default showModal ok click
          updateTotalTimerDisplay(); // Update total after setting timer
      });
  }
  function openColorFilters(){ var PALETTE=[{name:'Todas',hex:'*'},{name:'Sem cor',hex:''}].concat(buildFullPalette().map(function(p){return {name:p.name,hex:p.hex};})); showModal('Filtrar por cor', function(){ var wrap=el('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='repeat(auto-fill, minmax(120px, 1fr))'; wrap.style.gap='8px'; PALETTE.forEach(function(p){ var b=el('button'); b.type='button'; b.textContent=p.name; b.dataset.hex=p.hex; b.style.padding='10px'; b.style.borderRadius='8px'; b.style.border='1px solid #2a4e78'; b.style.background=(p.hex&&p.hex!=='*'?p.hex:'#0b2240'); b.style.color='#fff'; if((p.hex==='*' && selectedColors.size === 0) || selectedColors.has(p.hex)) b.style.outline='2px solid #fff'; b.onclick=function(){ if(p.hex==='*'){ selectedColors.clear(); } else { if(selectedColors.has(p.hex)) selectedColors.delete(p.hex); else selectedColors.add(p.hex); } [].slice.call(wrap.querySelectorAll('button')).forEach(function(btn){ btn.style.outline=''; if((btn.dataset.hex==='*' && selectedColors.size === 0) || selectedColors.has(btn.dataset.hex)) btn.style.outline='2px solid #fff'; }); }; wrap.appendChild(b); }); return wrap; }, function(body, okBtn){ applyFilters(); /* Modal removal handled by default */ }); }

  // ===== Gemini API Integration =====
  function showLoader(message) {
    var existing = document.getElementById('loader-wrap');
    if (existing) existing.remove();
    var wrap = el('div', 'modal-wrap');
    wrap.id = 'loader-wrap';
    wrap.style.display = 'flex'; wrap.style.justifyContent = 'center'; wrap.style.alignItems = 'center';
    var box = el('div', 'modal');
    box.style.padding = '20px'; box.style.textAlign = 'center';
    var spinner = el('div');
    spinner.innerHTML = `<svg width="24" height="24" viewBox="0 0 24" xmlns="http://www.w3.org/2000/svg"><g class="spinner_V8m1"><circle cx="12" cy="12" r="9.5" fill="none" stroke="#fff" stroke-width="3"></circle></g></svg>`;
    spinner.style.marginBottom = '12px';
    var msgEl = el('div');
    msgEl.textContent = message || 'Processando...';
    box.appendChild(spinner); box.appendChild(msgEl);
    wrap.appendChild(box);
    document.body.appendChild(wrap);
  }

  function hideLoader() {
    var wrap = document.getElementById('loader-wrap');
    if (wrap) wrap.remove();
  }

  async function callGemini(prompt, retries = 3, delay = 1000) {
    const apiKey = ""; // Provided by the environment
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };

    for (let i = 0; i < retries; i++) {
      try {
        const response = await fetch(apiUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const result = await response.json();
        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
        if (text) return text;
        else throw new Error('Resposta da API inválida ou vazia.');
      } catch (error) {
        if (i === retries - 1) {
          console.error("Erro final ao chamar a API Gemini:", error);
          throw error;
        }
        await new Promise(res => setTimeout(res, delay));
        delay *= 2; // Exponential backoff
      }
    }
  }

  async function generateSubtasks(block) {
    if (!block || !block.length) return;
    showLoader('✨ Gerando subtarefas com a IA...');
    try {
      for (const card of block) {
        const originalText = card.querySelector('.text').textContent;
        const prompt = `Aja como um assistente de produtividade. Quebre a seguinte tarefa em 3 a 5 subtarefas menores e acionáveis. Responda com uma lista de subtarefas, uma por linha. Não adicione nenhum outro texto, cabeçalhos, marcadores ou formatação. Tarefa: "${originalText}"`;
        const resultText = await callGemini(prompt);
        const subtasks = resultText.split('\n').map(s => s.trim()).filter(Boolean);
        if (subtasks.length > 0) {
          let lastCard = card;
          subtasks.forEach(taskText => {
            const newCard = createCard({ text: "・ " + taskText, color: card.dataset.color, due: card.dataset.due });
            // Add to DOM only if parent is Kanban/Matrix
             if (!card.closest('#agenda-sidebar')) {
                 lastCard.parentElement.insertBefore(newCard, lastCard.nextSibling);
                 lastCard = newCard;
             }
          });
        } else { throw new Error('Nenhuma subtarefa foi gerada.'); }
      }
       updateSlotsHasItems(); // Refresh agenda if needed
      persist();
      updateTotalTimerDisplay(); // Update total after potentially adding cards
    } catch (error) {
      showModal('Erro de IA', function() {
          var d=el('div');
          d.textContent = 'Não foi possível gerar as subtarefas. Por favor, tente novamente mais tarde.';
          return d;
      }, function(body, okBtn){ document.body.removeChild(okBtn.closest('.modal-wrap'));}); // Allow closing error modal
    } finally {
      hideLoader();
    }
  }

  async function organizeCardWithGemini(block) {
    if (!block || !block.length || !matrixEl) return;
    showLoader('✨ Analisando tarefa com IA...');
    const quadToColor = { Q1: MATRIX_COLORS.Q1, Q2: MATRIX_COLORS.Q2, Q3: MATRIX_COLORS.Q3, Q4: MATRIX_COLORS.Q4 };
    try {
      for (const card of block) {
        const originalText = card.querySelector('.text').textContent;
        const prompt = `Aja como um especialista em produtividade usando a Matriz de Eisenhower. Analise a seguinte tarefa e decida em qual quadrante ela se encaixa: Q1 (Urgente e Importante), Q2 (Não Urgente e Importante), Q3 (Urgente e Não Importante), ou Q4 (Não Urgente e Não Importante). Responda APENAS com "Q1", "Q2", "Q3", ou "Q4". Tarefa: "${originalText}"`;
        const resultQuad = (await callGemini(prompt)).trim().toUpperCase();
        if (quadToColor[resultQuad]) {
          const dest = matrixEl.querySelector('.list[data-quad="'+resultQuad+'"] .cards');
          if (dest) {
            // Update cache first
             const cardInCache = allCards.find(c => c === card);
             if (cardInCache) cardInCache.dataset.when = '';
             card.dataset.when = ''; // Also update DOM node just in case

            dest.appendChild(card); // Move in DOM
            card.dataset.color = quadToColor[resultQuad];
            paintCard(card);
          }
        } else { console.warn('Resposta inesperada da IA:', resultQuad); }
      }
      updateSlotsHasItems(); // Update agenda view as cards might have moved out
      persist();
      updateTotalTimerDisplay(); // Update total as card visibility might change
    } catch (error) {
      showModal('Erro de IA', function() {
          var d=el('div');
          d.textContent = 'Não foi possível organizar o cartão. Por favor, tente novamente mais tarde.';
          return d;
      }, function(body, okBtn){ document.body.removeChild(okBtn.closest('.modal-wrap'));}); // Allow closing error modal
    } finally {
      hideLoader();
    }
  }


  // ===== Inicialização e Eventos =====
  const toggleAgendaBtn = document.getElementById('toggleAgendaBtn');
  const workspaceEl = document.querySelector('.workspace');
  const AGENDA_STATE_KEY = 'mini-trello-agenda-state';

  // Toggle buttons from header
  const toggleBoardBtn = document.getElementById('toggleBoardBtn');
  const toggleMatrixBtn = document.getElementById('toggleMatrixBtn');
  const boardContainer = document.querySelector('.board-container');
  const matrixContainer = document.querySelector('.matrix-container');
  const agendaSidebar = document.getElementById('agenda-sidebar');
  const mainContent = document.getElementById('main-content');
  const BOARD_STATE_KEY = 'mini-trello-board-state';
  const MATRIX_STATE_KEY = 'mini-trello-matrix-state';


  function saveState() {
      localStorage.setItem(AGENDA_STATE_KEY, agendaSidebar.classList.contains('collapsed') ? 'collapsed' : 'open');
      localStorage.setItem(BOARD_STATE_KEY, boardContainer.classList.contains('collapsed') ? 'collapsed' : 'open');
      localStorage.setItem(MATRIX_STATE_KEY, matrixContainer.classList.contains('collapsed') ? 'collapsed' : 'open');
  }

  function loadState() {
      const agendaState = localStorage.getItem(AGENDA_STATE_KEY);
      const boardState = localStorage.getItem(BOARD_STATE_KEY);
      const matrixState = localStorage.getItem(MATRIX_STATE_KEY);

      if (agendaState === 'collapsed') {
          agendaSidebar.classList.add('collapsed');
          workspaceEl.classList.add('agenda-collapsed');
          toggleAgendaBtn.classList.remove('active');
      } else {
          agendaSidebar.classList.remove('collapsed');
          workspaceEl.classList.remove('agenda-collapsed');
          toggleAgendaBtn.classList.add('active');
      }

      if (boardState === 'collapsed') {
          boardContainer.classList.add('collapsed');
          mainContent.classList.add('board-collapsed');
          toggleBoardBtn.classList.remove('active');
      } else {
          boardContainer.classList.remove('collapsed');
          mainContent.classList.remove('board-collapsed');
          toggleBoardBtn.classList.add('active');
      }

      if (matrixState === 'collapsed') {
          matrixContainer.classList.add('collapsed');
          mainContent.classList.add('matrix-collapsed');
          toggleMatrixBtn.classList.remove('active');
      } else {
           matrixContainer.classList.remove('collapsed');
           mainContent.classList.remove('matrix-collapsed');
           toggleMatrixBtn.classList.add('active');
      }
  }

  toggleBoardBtn.addEventListener('click', () => {
      boardContainer.classList.toggle('collapsed');
      mainContent.classList.toggle('board-collapsed');
      toggleBoardBtn.classList.toggle('active');
      saveState();
  });

  toggleMatrixBtn.addEventListener('click', () => {
      matrixContainer.classList.toggle('collapsed');
      mainContent.classList.toggle('matrix-collapsed');
      toggleMatrixBtn.classList.toggle('active');
      saveState();
  });

  toggleAgendaBtn.addEventListener('click', () => {
      agendaSidebar.classList.toggle('collapsed');
      workspaceEl.classList.toggle('agenda-collapsed');
      toggleAgendaBtn.classList.toggle('active');
      saveState();
  });


  document.getElementById('addList').onclick=function(){ createList('Nova lista'); persist(); };
  document.getElementById('filterColorsBtn').addEventListener('click', openColorFilters);
  document.getElementById('undo').onclick=doUndo; document.getElementById('redo').onclick=doRedo;
  document.getElementById('clearFilters').onclick=function(){ selectedColors.clear(); document.getElementById('fFrom').value=''; document.getElementById('fTo').value=''; document.getElementById('fTime').value=''; applyFilters(); };
  document.getElementById('agendaDate').addEventListener('change', applyFilters ); // Use applyFilters directly
  document.getElementById('copyDay').addEventListener('click',function(){ showModal('Copiar agenda de…',function(){ var w=el('div'); var i=el('input'); i.type='date'; i.style.width='100%'; w.appendChild(i); return w; },function(w, okBtn){ var from=w.querySelector('input').value; if(!from) return; copyAgendaFrom(from, getActiveDay()); document.body.removeChild(okBtn.closest('.modal-wrap')); }); });
  $$('#fFrom, #fTo, #fTime').forEach(function(el){ el.addEventListener('input', applyFilters); });

  // Keyboard Shortcuts Listener
  document.addEventListener('keydown',function(e){
    // Undo/Redo
    if((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='z'){ e.preventDefault(); e.shiftKey? doRedo() : doUndo(); return; }

    // Ctrl+Enter to create card
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
         // Allow creating card even if input/editable is focused
        if (document.activeElement.tagName === 'INPUT' && document.activeElement.closest('.add')) {
             // If Enter is pressed in the 'New card...' input, let the form handle it
             return;
        }
         // Prevent default Enter behavior elsewhere
         e.preventDefault();

        let targetList = null;
        let insertAfterCard = null;

        if (selected.size > 0) {
            // Get the last selected card
            insertAfterCard = Array.from(selected).pop();
            targetList = insertAfterCard.closest('.list');
        } else {
            // Find list under mouse
            const lists = $$('.list'); // All list types
            targetList = lists.find(l => {
                // Only consider lists that are currently visible
                if (l.offsetParent === null) return false;
                const rect = l.getBoundingClientRect();
                return lastMouseX >= rect.left && lastMouseX <= rect.right &&
                       lastMouseY >= rect.top && lastMouseY <= rect.bottom;
            });
            // Default to first Kanban list if no list found under mouse or if it's hidden
            if (!targetList || targetList.offsetParent === null) {
                targetList = boardEl.querySelector('.list[data-type="kanban"]');
                // Ensure the default list is visible
                 if (!targetList || targetList.offsetParent === null) {
                    targetList = $$('.list[data-type="kanban"]').find(l => l.offsetParent !== null); // Find *any* visible kanban list
                 }
            }
             // Further fallback if even Kanban is hidden
             if (!targetList || targetList.offsetParent === null) {
                  targetList = $$('.list[data-type="quad"]').find(l => l.offsetParent !== null); // Try Matrix
             }
              if (!targetList || targetList.offsetParent === null) {
                  targetList = $$('.list[data-type="goal"], .list[data-type="time"]').find(l => l.offsetParent !== null); // Try Agenda
             }

        }

        if (targetList) {
            const cardsContainer = targetList.querySelector('.cards');
            if (cardsContainer) {
                 const newCard = createCard({ text: '' }); // Create blank
                 if (insertAfterCard && insertAfterCard.parentElement === cardsContainer) {
                     cardsContainer.insertBefore(newCard, insertAfterCard.nextSibling);
                 } else {
                     cardsContainer.appendChild(newCard); // Append to end if no selection or different list
                 }
                  applyWhen(targetList, [newCard]); // Handle agenda 'when' if needed
                 persist();
                 updateTotalTimerDisplay();
                 startInlineEdit(newCard); // Focus and edit immediately
            }
        }
        return; // Stop further key processing
    }

    // Shortcuts requiring selected cards or context menu target
    var currentSelection = getSelectionOr(ctxTarget);
    // Allow Del globally ONLY if nothing specific is focused/selected
    if (!currentSelection.length && !ctxTarget && (e.key==='Delete' || e.key==='Backspace')) {
         return; // Let browser handle if nothing relevant is targeted
    }
     // Ensure we don't interfere with text input UNLESS it's Del/Backspace on empty card text
     const activeEl = document.activeElement;
     const isEditingCard = activeEl.isContentEditable && activeEl.classList.contains('text') && activeEl.closest('.card');
     if ((activeEl.tagName === 'INPUT' || (activeEl.isContentEditable && !isEditingCard) )) return;


    // Context Menu Shortcuts (only if cards are selected)
    if (currentSelection.length > 0 && e.altKey) {
        if (e.key.toLowerCase() === 't') { e.preventDefault(); openTimerDialog(currentSelection); }
        else if (e.key.toLowerCase() === 'c') { e.preventDefault(); openColorDialog(currentSelection); }
        else if (e.key.toLowerCase() === 'd') { e.preventDefault(); openDateDialog(currentSelection); }
        return;
    }

     // Duplication Shortcut (only if cards are selected)
    if (currentSelection.length > 0 && (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'd') {
        e.preventDefault();
        duplicateCards(currentSelection);
        return;
    }

    // Deletion Shortcut (only if cards are selected OR if editing an empty card text)
     if( (currentSelection.length > 0 || (isEditingCard && activeEl.textContent.trim() === '')) && (e.key==='Delete' || e.key==='Backspace')){
        e.preventDefault(); // Prevent browser back navigation on Backspace

        const cardsToDelete = currentSelection.length > 0 ? Array.from(currentSelection) : [activeEl.closest('.card')];
        if (!cardsToDelete.length || !cardsToDelete[0]) return; // Safety check

        showConfirm('Excluir '+cardsToDelete.length+' cartão(s)?', function() {
            cardsToDelete.forEach(function(n){ removeCard(n); });
            clearSelection(); // Clear selection after delete
            // Persist called in removeCard
        });
        return;
    }

    // Card Movement Shortcut (Ctrl + Arrows) (only if cards are selected)
    if (currentSelection.length > 0 && (e.ctrlKey || e.metaKey)) {
        let moved = false;
        let targetCard = currentSelection[0]; // Use first selected as reference
        let parentCards = targetCard.parentElement;
        let parentList = targetCard.closest('.list');
        if (!parentCards || !parentList) return; // Card might be detached temporarily

        if (e.key === 'ArrowUp') {
            e.preventDefault();
            let previousCard = targetCard.previousElementSibling;
             while(previousCard && previousCard.style.display === 'none') { // Skip hidden cards
                previousCard = previousCard.previousElementSibling;
            }
            if (previousCard) {
                currentSelection.forEach(card => parentCards.insertBefore(card, previousCard));
                moved = true;
            }
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
             let lastCardInSelection = currentSelection[currentSelection.length - 1];
             let nextCard = lastCardInSelection.nextElementSibling;
              while(nextCard && nextCard.style.display === 'none') { // Skip hidden cards
                 nextCard = nextCard.nextElementSibling;
             }
             if (nextCard) {
                 // Move block before the next visible card
                 currentSelection.forEach(card => parentCards.insertBefore(card, nextCard));
                  moved = true;
             } else {
                  // Move block to the end
                  currentSelection.forEach(card => parentCards.appendChild(card));
                  moved = true; // Allow moving to end
             }
        } else if (e.key === 'ArrowLeft' && parentList.dataset.type === 'kanban') { // Only between Kanban lists
             e.preventDefault();
             let prevList = parentList.previousElementSibling;
             while(prevList && !prevList.matches('.list[data-type="kanban"]')) { // Find previous Kanban list
                 prevList = prevList.previousElementSibling;
             }
             if (prevList) {
                 let destCards = prevList.querySelector('.cards');
                  applyWhen(prevList, currentSelection); // Update 'when' before moving DOM
                 currentSelection.forEach(card => destCards.appendChild(card));
                 moved = true;
             }
        } else if (e.key === 'ArrowRight' && parentList.dataset.type === 'kanban') { // Only between Kanban lists
             e.preventDefault();
             let nextList = parentList.nextElementSibling;
              while(nextList && !nextList.matches('.list[data-type="kanban"]')) { // Find next Kanban list
                 nextList = nextList.nextElementSibling;
             }
             if (nextList) {
                 let destCards = nextList.querySelector('.cards');
                  applyWhen(nextList, currentSelection); // Update 'when' before moving DOM
                 currentSelection.forEach(card => destCards.appendChild(card));
                 moved = true;
             }
        }

        if (moved) {
             persist();
             applyFilters(); // Re-apply filters which also calls updateSlotsHasItems
             // Optionally scroll the moved card into view
             // currentSelection[0].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
         }
    }

  });
  document.addEventListener('click',function(e){ if(!ctx.contains(e.target) && !listCtx.contains(e.target)) { hideCtx(); listCtx.style.display='none'; } });

  // Import/Export/Reset
  var importFile = document.getElementById('importFile');
  document.getElementById('importJsonBtn').onclick=function(){ importFile.click(); };
  importFile.onchange = function(e){
    var file = e.target.files[0];
    if(!file) return;
    var reader=new FileReader();
    reader.onload=function(ev){
      try{
        var content = JSON.parse(ev.target.result);
        var dataToRestore = Array.isArray(content.data) ? content.data : content;
        if (!Array.isArray(dataToRestore)) {
            throw new Error("Formato JSON inválido. Array de dados não encontrado.");
        }
        // Prompt user for action
        promptImportAction(dataToRestore);

      }catch(err){
        showModal('Erro de Importação', function(){
            var d=el('div');
            d.textContent='Não foi possível ler o arquivo JSON. Verifique se o arquivo está no formato correto. Erro: ' + err.message;
            return d;
        },function(body, okBtn){ /* Modal removal handled by default click */ }); // Allow closing error modal
      }
    };
    reader.readAsText(file);
    e.target.value = ''; // Reset file input to allow re-importing the same file
  };

   // Function to prompt import action
  function promptImportAction(dataToRestore) {
      const { wrap, okButton, cancelButton } = showModal('Importar Dados', function() {
          var container = el('div');
          container.textContent = 'Como deseja importar os dados do ficheiro?';
          var btnRow = el('div', 'row import-options'); // Use row for button layout
          var replaceBtn = el('button'); replaceBtn.textContent = 'Substituir';
          var mergeBtn = el('button'); mergeBtn.textContent = 'Mesclar';

          replaceBtn.onclick = function() {
              restore(dataToRestore);
              persist();
              document.body.removeChild(container.closest('.modal-wrap'));
          };
          mergeBtn.onclick = function() {
              mergeData(dataToRestore);
              persist();
              document.body.removeChild(container.closest('.modal-wrap'));
          };

          btnRow.appendChild(replaceBtn);
          btnRow.appendChild(mergeBtn);
          container.appendChild(btnRow);

          // Return only the content part for showModal
          return container;
      }, function(body, okBtn) {
           // This function is only called when OK or Enter is pressed,
           // but we handle actions via custom buttons. So, do nothing here.
           // We keep the OK button hidden.
      });
      // Hide the default OK button provided by showModal
      if(okButton) okButton.style.display = 'none';
      if(cancelButton) cancelButton.textContent = 'Cancelar Importação';

      // Add keydown listener specifically for this modal to handle Enter on Merge/Replace? No, rely on focus + Enter.
  }

  // Function to merge imported data with existing data
  function mergeData(dataToMerge) {
      const currentKanbanLists = {};
      $$('.list[data-type="kanban"]', boardEl).forEach(l => {
          currentKanbanLists[l.querySelector('.title').value] = l.querySelector('.cards');
      });
      const quadMap = {
          Q1: matrixEl.querySelector('.list[data-quad="Q1"] .cards'),
          Q2: matrixEl.querySelector('.list[data-quad="Q2"] .cards'),
          Q3: matrixEl.querySelector('.list[data-quad="Q3"] .cards'),
          Q4: matrixEl.querySelector('.list[data-quad="Q4"] .cards')
      };

      dataToMerge.forEach(entry => {
          if (entry.type === 'kanban') {
              let targetContainer = currentKanbanLists[entry.title];
              if (!targetContainer) {
                  // Create list if it doesn't exist
                  const newList = createList(entry.title);
                  targetContainer = newList.querySelector('.cards');
                  currentKanbanLists[entry.title] = targetContainer; // Add to map
              }
              (entry.cards || []).forEach(cardData => {
                  // Avoid adding exact duplicates (simple check based on text) - could be more robust
                  const exists = Array.from(targetContainer.children).some(c => c.querySelector('.text').textContent.trim() === cardData.text.trim());
                  if (!exists) {
                      targetContainer.appendChild(createCard(cardData));
                  }
              });
          } else if (entry.type === 'quad' && quadMap[entry.quad]) {
              (entry.cards || []).forEach(cardData => {
                   const exists = Array.from(quadMap[entry.quad].children).some(c => c.querySelector('.text').textContent.trim() === cardData.text.trim());
                   if (!exists) {
                       quadMap[entry.quad].appendChild(createCard(cardData));
                   }
              });
          } else if (entry.type === 'time' || entry.type === 'goal') {
              (entry.cards || []).forEach(cardData => {
                   // Ensure 'when' is correctly formatted or assigned for goals
                   if (entry.goal && cardData.when && !cardData.when.endsWith('TGOAL')) {
                        cardData.when = (cardData.when.split('T')[0] || getActiveDay()) + 'TGOAL';
                   } else if (entry.time && cardData.when && !cardData.when.includes('T'+entry.time)) {
                       cardData.when = (cardData.when.split('T')[0] || getActiveDay()) + 'T' + entry.time;
                   }
                   // Check if card already exists in cache (more robust check needed)
                   const existsInCache = allCards.some(c => c.dataset.when === cardData.when && c.querySelector('.text').textContent.trim() === cardData.text.trim());
                   if (!existsInCache) {
                        createCard(cardData); // Add to cache, updateSlotsHasItems will handle DOM placement
                   }
              });
          }
      });
      applyFilters();
      updateSlotsHasItems();
      updateTotalTimerDisplay();
  }


   // Function to generate timestamp string
  function getTimestamp() {
      const now = new Date();
      const year = now.getFullYear();
      const month = to2(now.getMonth() + 1);
      const day = to2(now.getDate());
      const hour = to2(now.getHours());
      const minute = to2(now.getMinutes());
      return `${year}-${month}-${day}_${hour}${minute}`;
  }

  // Common export function used by both buttons
  function triggerExport() {
      const timestamp = getTimestamp();
      const filename = `mini-trello-backup-${timestamp}.json`;
      var a=document.createElement('a');
      a.href='data:application/json;charset=utf-8,'+encodeURIComponent(JSON.stringify(serialize(),null,2));
      a.download = filename;
      a.click();
  }

  // Wire up the export buttons
  document.getElementById('exportJson').onclick = triggerExport;
  document.getElementById('quickSaveBtn').onclick = triggerExport;

  document.getElementById('reset').onclick=function(){ showConfirm('Isso vai apagar TUDO e recomeçar com os dados de exemplo. Tem certeza?', function(){ localStorage.removeItem(LS_KEY); window.location.reload(); }); };

  // Kickstart
  initApp();
})();
</script>
</body>
</html>


